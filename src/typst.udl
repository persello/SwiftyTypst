namespace SwiftyTypst {
};

dictionary SourceLocation {
    u64 byte_offset;
    u64 line;
    u64 column;
};

dictionary SourceRange {
    SourceLocation start;
    SourceLocation end;
};

[Error]
enum FileError {
    "NotFound",
    "AccessDenied",
    "IsDirectory",
    "NotSource",
    "InvalidUtf8",
    "Package",
    "Other",
};

enum Severity {
    "Error",
    "Warning"
};

dictionary CompilationError {
    Severity severity;
    string? source_path;
    SourceRange? range;
    string message;
    sequence<string> hints;
};

[Enum]
interface CompilationResult {
    Document(sequence<u8> data, sequence<CompilationError> warnings);
    Errors(sequence<CompilationError> errors);
};

enum Tag {
    "Comment",
    "Punctuation",
    "Escape",
    "Strong",
    "Emph",
    "Link",
    "Raw",
    "Label",
    "Ref",
    "Heading",
    "ListMarker",
    "ListTerm",
    "MathDelimiter",
    "MathOperator",
    "Keyword",
    "Operator",
    "Number",
    "String",
    "Function",
    "Interpolated",
    "Error"
};

dictionary HighlightResult {
    u64 start;
    u64 end;
    Tag tag;
};

enum AutocompleteKind {
    "Syntax",
    "Func",
    "Param",
    "Constant",
    "Symbol",
    "Type"
};

dictionary AutocompleteResult {
    AutocompleteKind kind;
    string label;
    string completion;
    string description;
};

dictionary FontDefinition {
    sequence<u8> data;
};

interface TypstCompiler {
    constructor(FileManager file_manager, string main);
    [Throws=FileError]
    void set_main(string main);
    void add_font(FontDefinition font);
    void notify_change();
    void compile(TypstCompilerDelegate delegate);
    void highlight(TypstSourceDelegate delegate, string file_path);
    void autocomplete(TypstSourceDelegate delegate, string file_path, u64 line, u64 column);
};

callback interface TypstCompilerDelegate {
    void compilation_finished(CompilationResult result);
};

callback interface TypstSourceDelegate {
    void highlighting_finished(sequence<HighlightResult> result);
    void autocomplete_finished(sequence<AutocompleteResult> result);
};

callback interface FileManager {
    [Throws=FileManagerError]
    sequence<u8> read(string path);

    [Throws=FileManagerError]
    void write(string path, sequence<u8> data);

    [Throws=FileManagerError]
    boolean exists(string path);

    [Throws=FileManagerError]
    void create_directory(string path);
};

[Error]
enum FileManagerError {
    "NotFound",
    "AccessDenied",
    "IsDirectory",
    "NotSource",
    "InvalidUtf8",
    "FfiCallbackError",
    "Other",
};
